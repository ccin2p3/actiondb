use matcher::trie::node::{CompiledPattern};
use matcher::trie::node::{Node, NodeType};
use parsers::{SetParser, IntParser, Parser, OptionalParameter};
use grammar;

use std::str::FromStr;

#[pub]
pattern -> CompiledPattern
  = pattern_parts+
  / "" { Vec::new() }

pattern_parts -> NodeType
  = all_chars_until_parser_start {
      let unescaped_literal = grammar::unescape_literal(match_str);
      NodeType::Literal(unescaped_literal)
    }
  / "%{" pb:parser_body "}" { pb }

parser_body -> NodeType
  = pt:parser_type_with_params ":" parser_name:identifier {
    let mut parser = pt;
    parser.base_mut().set_name(parser_name.to_string());
    NodeType::Parser(parser)
  }
  / pt:parser_type_without_params ":" parser_name:identifier {
    let mut parser = pt;
    parser.base_mut().set_name(parser_name.to_string());
    NodeType::Parser(parser)
  }

parser_type_without_params -> Box<Parser>
  = parser_type:identifier {?
    if parser_type == "INT" {
      let parser = Box::new(IntParser::new());
      Ok(parser)
    } else {
      Err("No parser found with this type")
    }
  }

parser_type_with_params -> Box<Parser>
  = parser_SET_with_params
  / parser_INT_with_params

parser_SET_with_params -> Box<Parser>
  = "SET" "(" s:string po:parser_SET_optional_params? ")" {
    let mut parser = Box::new(SetParser::new());
    parser.set_character_set(s);

    if po.is_some() {
      parser.set_optional_params(po.unwrap());
    }

    parser
  }

parser_SET_optional_params -> Vec<OptionalParameter<'input>>
  = ", " params:parser_BASE_optional_param ** "," { params }

parser_BASE_optional_param -> OptionalParameter<'input>
  = key:param_min_len "=" value:int { OptionalParameter::Int(key, value) }
  / key:param_max_len "=" value:int { OptionalParameter::Int(key, value) }

parser_INT_with_params -> Box<Parser>
  = "INT" "(" ")" {
    Box::new(IntParser::new())
  }

param_min_len -> &'input str
  = "min_len" { match_str }

param_max_len -> &'input str
  = "max_len" { match_str }

identifier -> &'input str
  = ([a-z-A-Z0-9_]![-])+ { match_str }

all_chars_until_parser_start -> &'input str
  = (!"%{" .)+ { match_str }

string -> &'input str
  = '"' s:all_chars_until_quotation_mark '"' { s }

all_chars_until_quotation_mark -> &'input str
  = (!'"' .)+ { match_str }

int -> u64
  = [0-9]+ { u64::from_str(match_str).ok().unwrap() }
